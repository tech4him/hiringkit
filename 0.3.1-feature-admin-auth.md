# Feature Request: Admin Authentication & /admin Route Protection

**Date:** 2025-08-15
**Owner:** Platform
**Status:** Proposed (MVP-critical)

## 1) Background / Problem
- `/admin` currently renders the admin UI without authentication and shows **no data** because RLS blocks queries (no service-role or admin session).
- There is **no login** flow nor role-based access. Anyone can open `/admin`, and legitimate admins cannot see data.
- We must **gate all admin pages & APIs**, and allow authorized admins to query through RLS safely (no service key in the browser).

## 2) Goals (MVP)
1. **Protect** `/admin` and `/api/admin/*` behind authenticated **admin** users.
2. **Zero service key in client**. Use **RLS + user JWT** for reads/writes; keep service-role calls server-only.
3. Provide a **passwordless login** (email magic link/OTP) and an **admin role** pathway.
4. Admins can: list orders, filter by status, view kit, approve/publish, resend emails.
5. Non-admins get **403**. Anonymous users get **302 to /login**.

## 3) Non-goals
- Full user management, SSO, or team RBAC (post-MVP).
- Complex audit dashboards (basic audit logs only).

## 4) Approach (High-level)
- **Auth:** Supabase Auth (email magic link) + `users.role = 'admin'`.
- **RLS:** Allow admins to read/write across `orders`, `kits`, `exports`. Keep existing owner policies.
- **Next.js guards:**
  - `middleware.ts` ensures session for `/admin` and `/api/admin/*` (redirect to `/login` if not).
  - Server-side **`requireAdmin()`** verifies role via Supabase SSR client before page/API logic.
- **No service key in the browser.** Admin queries use the **user's JWT**; RLS permits admins.
- **Optional:** ENV allowlist for bootstrap: `ADMIN_EMAILS`.

## 5) Data Model / SQL (Supabase)
We already defined `users (id, email, role)`. Ensure `role` exists and create RLS policies to grant admin access.

See **`supabase_admin_policies.sql`** in this folder for full migration. Summary:
- Ensure `role` column on `users` and index.
- Helper function: `is_admin()` → returns true if current auth.uid() is an admin.
- Policies:
  - `orders`: owner read; **OR** admin read/write.
  - `kits`, `exports`, `export_assets`: owner read; **OR** admin read/write.
  - `audit_logs`: admin insert/select.

## 6) Next.js Changes
### 6.1 Middleware (auth gate)
```ts
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

const ADMIN_ROUTES = [/^\/admin(\/.*)?$/, /^\/api\/admin\//];

export function middleware(req: NextRequest) {
  const { pathname } = req.nextUrl;
  const matches = ADMIN_ROUTES.some((re) => re.test(pathname));
  if (!matches) return NextResponse.next();

  // Read session from Supabase cookie; we can't fully verify role here without a server call,
  // so we only check presence of the auth cookie and send to /login if missing.
  const hasSbSession = req.cookies.has('sb-access-token') || req.cookies.has('sb:token');
  if (!hasSbSession) {
    const url = new URL('/login', req.url);
    url.searchParams.set('redirect', pathname);
    return NextResponse.redirect(url);
  }
  // Allow through; page/API will call requireAdmin() server-side.
  return NextResponse.next();
}

export const config = {
  matcher: ['/admin/:path*', '/api/admin/:path*'],
};
```

### 6.2 Server helpers
```ts
// lib/supabaseServer.ts
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export function createSupabaseServerClient() {
  const cookieStore = cookies();
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    { cookies: { get: (name) => cookieStore.get(name)?.value } }
  );
}

// lib/requireAdmin.ts
import { redirect } from 'next/navigation';
import { createSupabaseServerClient } from './supabaseServer';

export async function requireAdmin() {
  const supabase = createSupabaseServerClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) redirect('/login');

  // Check role via RLS-safe query
  const { data: row, error } = await supabase.from('users').select('role').eq('id', user.id).single();
  if (error || !row || row.role !== 'admin') {
    throw new Error('FORBIDDEN');
  }
  return { supabase, user };
}
```

### 6.3 Admin page guard
```tsx
// app/admin/page.tsx
import { requireAdmin } from '@/lib/requireAdmin';

export default async function AdminPage() {
  const { supabase } = await requireAdmin();
  const { data: orders } = await supabase
    .from('orders')
    .select('id, status, total_cents, created_at, kits(title), users(email)')
    .order('created_at', { ascending: false })
    .limit(100);
  return <AdminUI orders={orders||[]} />;
}
```

### 6.4 Admin API guard
```ts
// app/api/admin/orders/route.ts
import { NextResponse } from 'next/server';
import { requireAdmin } from '@/lib/requireAdmin';

export async function GET() {
  try {
    const { supabase } = await requireAdmin();
    const { data, error } = await supabase.from('orders').select('*').limit(200);
    if (error) throw error;
    return NextResponse.json(data);
  } catch {
    return NextResponse.json({ error: 'forbidden' }, { status: 403 });
  }
}
```

## 7) Login Page (passwordless)
- Route: `/login` with email input; magic link via Supabase.
- Copy: “Admins sign in to manage orders. If you need access, contact owner.”
- On success, redirect to `redirect` param or `/admin`.

```tsx
// app/login/page.tsx (client component)
'use client';
import { useState } from 'react';
import { createClient } from '@supabase/supabase-js';

export default function LoginPage() {
  const [email, setEmail] = useState('');
  const supabase = createClient(process.env.NEXT_PUBLIC_SUPABASE_URL!, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!);

  async function sendLink(e: any) {
    e.preventDefault();
    await supabase.auth.signInWithOtp({ email, options: { emailRedirectTo: window.location.origin + '/admin' } });
    alert('Check your email for the sign-in link.');
  }

  return (
    <main className="mx-auto max-w-md p-6">
      <h1 className="text-2xl font-semibold">Admin sign in</h1>
      <form onSubmit={sendLink} className="mt-4 space-y-3">
        <input className="w-full rounded-2xl border px-4 py-3" placeholder="you@org.org" value={email} onChange={(e)=>setEmail(e.target.value)} />
        <button className="rounded-2xl bg-sky-700 px-5 py-3 text-white">Send magic link</button>
      </form>
    </main>
  );
}
```

## 8) Bootstrap Options for Admins
- **A. Role column:** set `users.role='admin'` for your user.
- **B. Allowlist (env):** `ADMIN_EMAILS=you@org.org,cofounder@org.org`—on login, a server hook upgrades `users.role` to admin if email matches.
- **C. Seed SQL:** included in `supabase_admin_policies.sql` to grant the first admin.

## 9) Security Notes
- Cookies only; no tokens in localStorage. `SameSite=Lax`, `Secure` in prod.
- All admin API endpoints live under `/api/admin/*` and call `requireAdmin()`.
- **No service role** in client bundles. If a server action needs service-role (e.g., resend email), do it in a Route Handler **after** `requireAdmin()`.
- Signed URLs for downloads (short TTL); never expose Storage public.

## 10) Telemetry
- Events: `admin_login`, `admin_view_orders`, `admin_view_kit`, `admin_approve`, `admin_export_csv`.
- Log 403s (path, user id) to detect probing.

## 11) Acceptance Criteria
- Visiting `/admin` unauthenticated → **redirects to /login**.
- Visiting `/admin` as non-admin → **403** on APIs and page shows “Access denied”.
- Authenticated admin can:
  - See orders list with filters.
  - Open an order detail and kit preview.
  - Approve/mark ready; email triggers.
- RLS: admin can select across `orders/kits/exports`; non-admin cannot.
- No service-role keys in browser bundles (verified via `grep`).

## 12) Test Plan
- Unit: `requireAdmin()` throws for non-admin; passes for admin.
- Integration: middleware redirect works; API returns 403 without admin.
- RLS: attempt direct select from non-admin session returns 0 rows.
- E2E: login → /admin → approve order → customer receives email.

## 13) Rollout
1. Apply SQL migration.
2. Set `ADMIN_EMAILS` in env for bootstrap (optional).
3. Deploy Next.js changes.
4. Promote first admin by setting `users.role='admin'`.
5. Verify with an incognito non-admin session.

## 14) Open Questions
- Do we need an **admin users** table separate from `users.role`? (current plan: role column is enough.)
- Should we add **MFA** for admins now or later?
- Do we gate by **domain** (e.g., *@company.org) as a convenience?

---

### Appendix A — Minimal Order Detail API
```ts
// app/api/admin/orders/[id]/route.ts
import { NextResponse } from 'next/server';
import { requireAdmin } from '@/lib/requireAdmin';
export async function GET(_: Request, { params }: { params: { id: string } }) {
  try {
    const { supabase } = await requireAdmin();
    const { data, error } = await supabase
      .from('orders')
      .select('*, kits(*), users(email)')
      .eq('id', params.id)
      .single();
    if (error) throw error;
    return NextResponse.json(data);
  } catch {
    return NextResponse.json({ error: 'forbidden' }, { status: 403 });
  }
}
```
