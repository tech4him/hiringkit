name: "Edit-lite Before Pay Feature - v0.3.0"
description: |

## Purpose
Implement an "Edit-lite before pay" feature that allows users to personalize key inputs and regenerate specific sections before purchasing, while maintaining sales-safe preview restrictions to drive conversions.

## Core Principles
1. **Sales-Safe Editing**: Users can edit inputs and see limited output changes without accessing full content
2. **Micro-Regeneration**: Section-by-section regeneration with pre-purchase limits
3. **Smart Suggestions**: Contextual chips and AI helpers to improve input quality
4. **Progressive Enhancement**: Build on existing architecture without breaking current flow

---

## Goal
Transform the current "generate → preview → buy" flow into "generate → edit-lite → checkout" by adding focused editing capabilities for high-leverage fields before purchase, while keeping the preview sales-safe and conversion-optimized.

## Why
- **Ownership Psychology**: Users feel ownership through customization, increasing conversion rates
- **Reduced Refunds**: Better fit before payment reduces post-purchase dissatisfaction  
- **Competitive Advantage**: Unique middle-ground between full preview and black-box generation
- **User Confidence**: Ability to refine core inputs builds trust in the final product

## What
Users can edit specific high-impact fields after generation but before purchase:
- **Role**: Title, Mission (1-2 lines)
- **Scorecard**: Outcomes (up to 3), Responsibilities (up to 5)  
- **Job Post**: Must/Should have requirements (up to 5 each)
- **Interview Pack**: Add/remove questions per stage (up to 3 from suggestions)
- **Work Sample**: Scenario one-liner

### Success Criteria
- [ ] Users can edit intake fields and see live preview updates (truncated/watermarked)
- [ ] Section regeneration works with 3-regen limit per section pre-purchase
- [ ] Smart helpers provide contextual suggestions and AI quick actions
- [ ] Industry/seniority/style presets influence regeneration prompts
- [ ] Full editing unlocks post-purchase with unlimited regenerations
- [ ] Preview maintains sales-safe restrictions (first page, truncated, watermarked)
- [ ] All validation gates pass: linting, type checking, build success

## All Needed Context

### Documentation & References
```yaml
# MUST READ - Include these in your context window
- url: https://nextjs.org/docs/app/api-reference/file-conventions/route
  why: App Router API patterns for PATCH endpoint and section regeneration

- url: https://mui.com/material-ui/react-chip/
  why: Chip component patterns for suggestion helpers

- file: app/api/kits/generate/route.ts
  why: Current generation pattern to extend for section regeneration

- file: components/kit/IntakeForm.tsx  
  why: Current input patterns to enhance with editing capabilities

- file: components/kit/KitPreview.tsx
  why: Preview component to modify for live updates with edit restrictions

- file: lib/ai/generate.ts
  why: AI generation patterns to replicate for section-specific regeneration

- file: types/index.ts
  why: Data structures for Kit, IntakeData, KitArtifacts, ArtifactType

- file: lib/validation/schemas.ts
  why: Validation patterns and ArtifactType enum for section regeneration
```

### Current Codebase Tree (key files)
```bash
hiringkit/
├── app/
│   ├── api/
│   │   └── kits/
│   │       ├── generate/route.ts          # Current generation endpoint
│   │       └── [id]/route.ts             # Kit retrieval
│   └── kit/[id]/page.tsx                 # Kit display page
├── components/
│   └── kit/
│       ├── IntakeForm.tsx                # Current input form
│       └── KitPreview.tsx               # Current preview component
├── lib/
│   ├── ai/generate.ts                    # OpenAI generation logic
│   └── validation/schemas.ts             # Zod schemas
└── types/index.ts                        # TypeScript interfaces
```

### Desired Codebase Tree (new files and modifications)
```bash
hiringkit/
├── app/api/kits/
│   └── [id]/
│       ├── inputs/route.ts              # NEW: PATCH endpoint for intake updates
│       └── sections/
│           └── [section]/
│               └── regenerate/route.ts   # NEW: POST section regeneration
├── components/
│   ├── kit/
│   │   ├── EditLiteForm.tsx             # NEW: Edit-lite interface component
│   │   ├── SuggestionChips.tsx          # NEW: Smart suggestion helpers
│   │   ├── SectionRegenButton.tsx       # NEW: Micro-regen button with counter
│   │   └── PresetDropdowns.tsx          # NEW: Industry/seniority/style selectors
│   └── ui/
│       └── chip.tsx                     # NEW: Base chip component
├── lib/
│   └── ai/
│       └── section-generate.ts          # NEW: Section-specific generation logic
└── hooks/
    ├── useEditLite.ts                   # NEW: Edit-lite state management
    └── useRegenLimits.ts                # NEW: Regeneration limit tracking
```

### Known Gotchas & Library Quirks
```typescript
// CRITICAL: OpenAI API has different prompting for section regeneration
// Pattern: Include existing intake data as context for consistency

// CRITICAL: Supabase edited_json field merges over artifacts_json
// Pattern: Always merge edits preserving unmodified sections

// CRITICAL: Next.js App Router requires proper params typing
// Pattern: { params }: { params: Promise<{ id: string, section: string }> }

// CRITICAL: Zod ArtifactType enum must match exactly
// Values: 'scorecard' | 'job_post' | 'interview_stage1' | 'interview_stage2' | 'interview_stage3' | 'work_sample'

// CRITICAL: Preview component truncation logic must remain intact
// Pattern: truncateText(text, wordLimit) and watermark overlay preservation
```

## Implementation Blueprint

### Data Models and Structure

Extend existing types for edit-lite functionality:
```typescript
// EXTEND Kit interface for regen tracking
interface Kit {
  // ... existing fields
  regen_counts?: { [section: string]: number } // Track section regeneration limits
  edited_at?: string // Track when last edited
}

// NEW: Edit-lite request schemas
interface UpdateKitInputsRequest {
  field_updates: Partial<IntakeData>
}

interface RegenerateSecti onRequest {
  section: ArtifactType
  intake_overrides?: Partial<IntakeData> // Context from current edits
  style_settings?: {
    industry?: 'general' | 'nonprofit' | 'education' | 'faith_based' | 'smb'
    seniority?: 'coordinator' | 'manager' | 'director' 
    style?: 'formal' | 'plain_english' | 'friendly'
  }
}
```

### List of Tasks (Implementation Order)

```yaml
Task 1: Create Base UI Components
CREATE components/ui/chip.tsx:
  - MIRROR pattern from: Radix UI components in components/ui/
  - IMPLEMENT dismissible chips with close button
  - INCLUDE hover states and accessibility

CREATE components/kit/SuggestionChips.tsx:
  - IMPLEMENT clickable suggestion insertion
  - PATTERN: onClick handler adds text to parent input
  - INCLUDE curated suggestions per field type

Task 2: Extend Database Schema
MODIFY kit table (via Supabase):
  - ADD regen_counts JSONB field for section limits
  - ADD edited_at timestamp field
  - KEEP existing edited_json merge pattern

Task 3: Create Section Regeneration API
CREATE app/api/kits/[id]/sections/[section]/regenerate/route.ts:
  - MIRROR pattern from: app/api/kits/generate/route.ts
  - IMPLEMENT POST handler with section-specific prompts
  - ENFORCE 3-regen limit for non-paid users
  - UPDATE regen_counts in database

CREATE lib/ai/section-generate.ts:
  - EXTRACT section-specific prompting from lib/ai/generate.ts
  - IMPLEMENT prompt enhancement with style_settings
  - MAINTAIN consistency with existing intake data

Task 4: Create Input Update API  
CREATE app/api/kits/[id]/inputs/route.ts:
  - IMPLEMENT PATCH handler for partial IntakeData updates
  - VALIDATE using existing IntakeDataSchema (partial)
  - UPDATE intake_json field, preserve artifacts_json

Task 5: Build Edit-Lite Interface
CREATE components/kit/EditLiteForm.tsx:
  - MIRROR structure from: components/kit/IntakeForm.tsx
  - IMPLEMENT focused editing for specified fields only
  - INCLUDE SuggestionChips for outcomes/responsibilities
  - ADD real-time validation feedback

CREATE components/kit/PresetDropdowns.tsx:
  - IMPLEMENT industry/seniority/style selectors
  - PATTERN: Controlled components with onChange handlers
  - INCLUDE tooltip explanations for each option

CREATE components/kit/SectionRegenButton.tsx:
  - IMPLEMENT micro-regeneration with loading states
  - DISPLAY counter "2/3" for remaining regenerations
  - DISABLE when limit reached with upgrade prompt

Task 6: Enhance Kit Preview
MODIFY components/kit/KitPreview.tsx:
  - ADD live update capability for edited artifacts
  - PRESERVE existing truncation and watermark logic
  - IMPLEMENT optimistic updates during regeneration

Task 7: State Management
CREATE hooks/useEditLite.ts:
  - IMPLEMENT intake field updates with debouncing
  - MANAGE optimistic UI updates
  - HANDLE API errors gracefully

CREATE hooks/useRegenLimits.ts:
  - TRACK regeneration counts per section
  - IMPLEMENT limit enforcement logic
  - PROVIDE upgrade prompts when limits reached

Task 8: Integrate Edit-Lite into Kit Page
MODIFY app/kit/[id]/page.tsx:
  - ADD EditLiteForm between generate and preview
  - IMPLEMENT conditional rendering based on kit status
  - MAINTAIN existing checkout flow
```

### Per Task Pseudocode

```typescript
// Task 3: Section Regeneration API
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string, section: string }> }
) {
  // PATTERN: Follow existing auth and validation from kits/generate
  const { id: kitId, section } = await params
  const body = await request.json()
  
  // CRITICAL: Validate section against ArtifactType enum
  if (!ArtifactTypeSchema.safeParse(section).success) {
    return createNextResponse(createApiError('INVALID_SECTION'), 400)
  }
  
  // GOTCHA: Check regen limits before proceeding
  const kit = await getKit(kitId)
  const currentCount = kit.regen_counts?.[section] || 0
  if (!kit.order_id && currentCount >= 3) {
    return createNextResponse(createApiError('REGEN_LIMIT_EXCEEDED'), 429)
  }
  
  // PATTERN: Use existing generateKitArtifacts with section override
  const updatedArtifacts = await generateSectionArtifacts({
    section,
    intake: { ...kit.intake_json, ...body.intake_overrides },
    style_settings: body.style_settings
  })
  
  // PATTERN: Merge into edited_json preserving other sections
  const newEditedJson = {
    ...kit.artifacts_json,
    ...kit.edited_json,
    [section]: updatedArtifacts[section]
  }
  
  // CRITICAL: Increment regen count
  const newRegenCounts = {
    ...kit.regen_counts,
    [section]: currentCount + 1
  }
  
  await updateKit(kitId, { 
    edited_json: newEditedJson,
    regen_counts: newRegenCounts,
    edited_at: new Date().toISOString()
  })
}

// Task 5: Edit-Lite Interface Logic
function EditLiteForm({ kitId, initialData }: EditLiteFormProps) {
  // PATTERN: Debounced updates to prevent API spam
  const [localData, setLocalData] = useState(initialData)
  const debouncedUpdate = useDebouncedCallback(
    (updates: Partial<IntakeData>) => {
      updateKitInputs(kitId, updates)
    },
    500 // GOTCHA: 500ms debounce prevents excessive API calls
  )
  
  // PATTERN: Field-specific editing restrictions
  const editableFields = {
    basic: ['role_title', 'mission'],
    scorecard: ['outcomes', 'responsibilities'], 
    job_post: ['must_have', 'nice_to_have'],
    interview: ['stage1_questions', 'stage2_questions', 'stage3_questions'],
    work_sample: ['work_sample_scenario']
  }
  
  // CRITICAL: Array field handling matches existing pattern
  const updateArrayField = (field: string, value: string) => {
    const items = value.split('\n').filter(item => item.trim())
    // PATTERN: Respect pre-purchase limits
    const limit = getFieldLimit(field) // outcomes: 3, responsibilities: 5, etc.
    const trimmed = items.slice(0, limit)
    
    setLocalData(prev => ({ ...prev, [field]: trimmed }))
    debouncedUpdate({ [field]: trimmed })
  }
}
```

### Integration Points
```yaml
DATABASE:
  - migration: "ALTER TABLE kits ADD COLUMN regen_counts JSONB, ADD COLUMN edited_at TIMESTAMP"
  - index: "CREATE INDEX idx_kits_edited ON kits(edited_at)" # For analytics
  
API_ROUTES:
  - add: "app/api/kits/[id]/inputs/route.ts"
  - add: "app/api/kits/[id]/sections/[section]/regenerate/route.ts"
  - pattern: "Follow existing createNextResponse and validation helpers"
  
COMPONENTS:
  - modify: "components/kit/KitPreview.tsx" 
  - pattern: "Add optimistic updates while preserving sales-safe restrictions"
  
VALIDATION:
  - extend: "lib/validation/schemas.ts"
  - add: "UpdateKitInputsSchema, RegenerateSectionSchema"
```

## Validation Loop

### Level 1: Syntax & Style
```bash
# Run these FIRST - fix any errors before proceeding
npm run lint                              # ESLint checking
npx tsc --noEmit                         # TypeScript compilation check

# Expected: No errors. If errors, read carefully and fix systematically.
```

### Level 2: Unit Tests (Test Key Functions)
```typescript
// CREATE __tests__/api/section-regenerate.test.ts
describe('Section Regeneration API', () => {
  test('regenerates scorecard section successfully', async () => {
    const response = await POST(mockRequest, { params: { id: 'kit-123', section: 'scorecard' }})
    expect(response.status).toBe(200)
    const data = await response.json()
    expect(data.success).toBe(true)
  })
  
  test('enforces 3-regen limit for unpaid users', async () => {
    // Mock kit with 3 existing regens
    const response = await POST(mockRequest, { params: { id: 'kit-limit', section: 'scorecard' }})
    expect(response.status).toBe(429)
  })
  
  test('allows unlimited regens for paid users', async () => {
    // Mock kit with order_id
    const response = await POST(mockRequest, { params: { id: 'kit-paid', section: 'scorecard' }})
    expect(response.status).toBe(200)
  })
})

// CREATE __tests__/components/EditLiteForm.test.tsx  
describe('EditLiteForm', () => {
  test('debounces input updates correctly', async () => {
    render(<EditLiteForm kitId="test" initialData={mockData} />)
    const input = screen.getByLabelText('Mission')
    
    fireEvent.change(input, { target: { value: 'Updated mission' }})
    expect(mockUpdateInputs).not.toHaveBeenCalled() // Immediate
    
    await waitFor(() => {
      expect(mockUpdateInputs).toHaveBeenCalledWith('test', { mission: 'Updated mission' })
    }, { timeout: 600 }) // After debounce
  })
})
```

```bash
# Run and iterate until passing:
npm test -- --testPathPattern="section-regenerate|EditLiteForm"
# If failing: Read error messages, understand root cause, fix code, re-run
```

### Level 3: Integration Test
```bash
# Start development server
npm run dev

# Test section regeneration endpoint
curl -X POST http://localhost:3000/api/kits/[test-kit-id]/sections/scorecard/regenerate \
  -H "Content-Type: application/json" \
  -d '{
    "intake_overrides": {"mission": "Updated mission statement"},
    "style_settings": {"industry": "nonprofit", "style": "friendly"}
  }'

# Expected: {"success": true, "data": {...}, "message": "Section regenerated successfully"}

# Test input updates
curl -X PATCH http://localhost:3000/api/kits/[test-kit-id]/inputs \
  -H "Content-Type: application/json" \
  -d '{
    "field_updates": {
      "role_title": "Senior Marketing Manager",
      "outcomes": ["Increase brand awareness", "Drive lead generation", "Improve conversion rates"]
    }
  }'

# Expected: {"success": true, "data": {...}, "message": "Kit inputs updated successfully"}
```

## Final Validation Checklist
- [ ] All tests pass: `npm test`
- [ ] No linting errors: `npm run lint`  
- [ ] No type errors: `npx tsc --noEmit`
- [ ] Build succeeds: `npm run build`
- [ ] Manual integration tests pass (curl commands above)
- [ ] Edit-lite form allows field editing with live preview updates
- [ ] Section regeneration respects 3-regen limit for unpaid users
- [ ] Suggestion chips provide helpful context-aware suggestions
- [ ] Preview maintains sales-safe restrictions (truncation, watermarks)
- [ ] Industry/seniority/style presets influence generation appropriately
- [ ] Post-purchase editing unlocks unlimited capabilities

---

## Anti-Patterns to Avoid
- ❌ Don't break existing preview sales-safe restrictions
- ❌ Don't allow unlimited regenerations for unpaid users
- ❌ Don't create new data structures when existing ones work  
- ❌ Don't ignore the existing truncateText and watermark patterns
- ❌ Don't skip debouncing on input updates (causes API spam)
- ❌ Don't hard-code suggestion chips - make them contextual
- ❌ Don't bypass existing validation schemas
- ❌ Don't implement without proper error handling and loading states

## PRP Quality Score: 9/10

**Confidence Level**: Very High - This PRP provides comprehensive context including existing codebase patterns, external documentation references, detailed implementation steps with pseudocode, and robust validation gates. The progressive approach (API → Components → Integration) minimizes risk while the validation loop ensures quality. All necessary context for one-pass implementation is included with specific file references, gotchas, and patterns to follow.

**Areas for Success**:
✅ Detailed codebase analysis with existing patterns  
✅ External documentation URLs for modern React and Next.js patterns
✅ Progressive implementation order with clear dependencies
✅ Comprehensive validation gates (syntax, unit tests, integration)
✅ Specific pseudocode with critical gotchas highlighted
✅ Sales-safe considerations maintained throughout
✅ Error handling and edge cases considered

**Potential Risk**: Minor complexity in coordinating multiple new components, but mitigated by following existing patterns and progressive validation approach.