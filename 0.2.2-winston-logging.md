Feature: Implement Winston Logging

Status: ProposedOwner: Platform / App InfraReviewers: App team, Security, DevOpsTarget: Next.js (App Router) SaaS — Node.js runtime routes and server actions

Summary

Replace Pino with Winston for server-side logging to avoid worker_threads requirements and ensure compatibility with Vercel and other serverless Node environments. Provide a single, typed, JSON-structured logger with minimal overhead, centralized configuration, and clear conventions.

Goals

✅ Work reliably on Vercel/Serverless (no worker_threads)

✅ Emit structured JSON logs to stdout for platform ingestion

✅ Centralize configuration and level control via env vars

✅ Provide safe error serialization (no secrets)

✅ Offer simple helpers for HTTP/route logging and tracing fields (request id, user id)

✅ Zero file-based transports; console-only

Non‑Goals

❌ Long-term log retention/analytics (handled by platform drains)

❌ File rotation or local persistence

❌ Client-side logging (out of scope)

Design Overview

We will introduce a lightweight Winston setup under lib/logger.ts with:

JSON format with timestamp and level

Redaction of known sensitive keys

Error serializer that captures name, message, stack (trimmed)

Helpers: withContext() to add per-request fields (e.g., reqId, userId)

Levels: error, warn, info, http, debug, configurable via LOG_LEVEL

Why Winston vs. Pino

No worker threads required

Mature ecosystem, Console transport suffices for serverless

Flexible formatting without extra processes

Public API (proposed)

// lib/logger.ts
import winston from 'winston';

export type LogContext = Record<string, unknown> & {
  reqId?: string;
  userId?: string;
  route?: string;
};

function redact(obj: any): any {
  const SENSITIVE = ['authorization', 'password', 'token', 'apiKey', 'secret'];
  if (!obj || typeof obj !== 'object') return obj;
  const copy: Record<string, unknown> = Array.isArray(obj) ? [...obj] as any : { ...obj };
  for (const k of Object.keys(copy)) {
    const v = (copy as any)[k];
    if (SENSITIVE.includes(k.toLowerCase())) {
      (copy as any)[k] = '[REDACTED]';
    } else if (v && typeof v === 'object') {
      (copy as any)[k] = redact(v);
    }
  }
  return copy;
}

export function safeError(err: unknown) {
  if (!err || typeof err !== 'object') return { message: String(err) };
  const e = err as any;
  return {
    name: e.name,
    message: e.message,
    stack: process.env.NODE_ENV === 'production' ? undefined : e.stack,
  };
}

const baseFormat = winston.format.combine(
  winston.format.timestamp(),
  winston.format.printf(({ level, message, timestamp, ...meta }) => {
    const entry = {
      ts: timestamp,
      level,
      msg: typeof message === 'string' ? message : JSON.stringify(message),
      ...meta,
    };
    return JSON.stringify(redact(entry));
  })
);

export const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || (process.env.NODE_ENV === 'production' ? 'info' : 'debug'),
  format: baseFormat,
  transports: [new winston.transports.Console()],
});

export function withContext(ctx: LogContext) {
  return {
    error: (msg: string, meta?: any) => logger.error(msg, { ...ctx, ...(meta ? redact(meta) : {}) }),
    warn:  (msg: string, meta?: any) => logger.warn(msg,  { ...ctx, ...(meta ? redact(meta) : {}) }),
    info:  (msg: string, meta?: any) => logger.info(msg,  { ...ctx, ...(meta ? redact(meta) : {}) }),
    debug: (msg: string, meta?: any) => logger.debug(msg, { ...ctx, ...(meta ? redact(meta) : {}) }),
    http:  (msg: string, meta?: any) => logger.http ? (logger as any).http(msg, { ...ctx, ...(meta ? redact(meta) : {}) }) : logger.info(msg, { ...ctx, ...(meta ? redact(meta) : {}) }),
  };
}

Usage in a Node runtime route

// app/api/jobs/[jobId]/status/route.ts
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';
export const revalidate = 0;

import { NextResponse } from 'next/server';
import { withContext, safeError } from '@/lib/logger';

export async function GET(_req: Request, { params }: { params: { jobId: string } }) {
  const log = withContext({ route: '/api/jobs/[jobId]/status', reqId: crypto.randomUUID() });
  try {
    log.info('status request received', { jobId: params.jobId });
    // ... business logic
    return NextResponse.json({ status: 'ok' });
  } catch (err) {
    log.error('status request failed', { err: safeError(err), jobId: params.jobId });
    return NextResponse.json({ error: 'internal_error' }, { status: 500 });
  }
}

Configuration

Environment variables

LOG_LEVEL — default info in prod, debug otherwise

Transports

Console only. No file transports. Logs are ingested by Vercel and other providers via stdout.

Format

JSON line per log entry including timestamp, level, message, and merged context.

NO WORKER THREADS OR WORKERS